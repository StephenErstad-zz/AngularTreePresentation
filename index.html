<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>AngularJS Tree Directive</title>

    <meta name="description" content="Building a high performance tree control for AngularJS">
    <meta name="author" content="Troy Dey & Stephen Erstad">

    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>

<div class="reveal">

    <!-- Any section element inside of this container is displayed as a slide -->
    <div class="slides">
        <section>
            <h1>AngularJS Tree Directive</h1>

            <h3>Building a high performance tree control for AngularJS</h3>

            <p>
                <small>Created by Troy Dey</small>
                <small>And Stephen Erstad</small>
            </p>
            
            <aside class="notes">
                s: speaker view
                b: pause
                o: overview
                p: previous slide
                n: next slide
                alt-click: zoom in/out
            </aside>
        </section>

        <section>
            <section>
                <h2>What's in a tree?</h2>

                <p>What features do we need?</p>

                <p>What are our performance requirements</p>
            </section>
            <section>
                <h2>Features</h2>
                <ul>
                    <li>Multiple Roots</li>
                    <li>
                        Add
                        <ul>
                            <li>As Child</li>
                            <li>As Sibling</li>
                            <li>As Root</li>
                        </ul>
                    </li>
                    <li>Edit</li>
                    <li>Delete</li>
                    <li>
                        Move subtrees
                        <ul>
                            <li>As Child</li>
                            <li>As Sibling</li>
                        </ul>
                    </li>
                    <li>Select/Deselect</li>
                    <li>Lazy Loading</li>
                    <li>Containing Controller Interaction</li>
                </ul>
            </section>
            <section>
                <h2>Performance</h2>
                <ul>
                    <li>Total # Nodes: > 10k</li>
                    <li>Depth: > 10</li>
                    <li>Memory Restriction: &lt; 50MB for 10k nodes</li>
                    <li>Time to Render: &lt; 3 sec for 10k nodes</li>
                    <li>Time for Operation: &lt; 3 sec for 10k nodes</li>
                </ul>
            </section>
        </section>

        <section>
            <h2>Challenges w/ Tree Controls in AngularJS</h2>
            <ul>
                <li>Trees more than 10 levels deep</li>
                <li>Allow user to specify their own template for nodes (transclusion)</li>
                <li>Large number of nodes</li>
                <li>Communication (Isolate Scope)</li>
                <aside class="notes">
                    All the trees that got around the digest issue did not allow transclusion, the templates were hard coded in the directive.
                </aside>
            </ul>
        </section>

        <!--Stephen-->
        <section>
            <section>
                <h2>Digest Cycle</h2>

                <p class="fragment">
                    We know this is occurring but why?
                </p>

                <p class="fragment">
                    Or maybe we don't and our sites run like Windows Vista?
                </p>
            </section>
            <section>
                <h2>Overview</h2>

                <p class="fragment">
                    Processes Watchers
                </p>

                <p class="fragment">
                    Changes while processing trigger more Digest() calls
                </p>

                <p class="fragment">
                    To avoid infinite loops, an arbitrary limit of 10 cycles is set
                </p>

                <aside class="notes">
                    Processes all of the watchers of the current scope and its children.
                    <br><br>
                    Because a watcher's listener can change the model, the `$digest()` keeps calling the watchers until
                    no more listeners are firing.
                    <br><br>
                    This means that it is possible to get into an infinite loop.
                    This function will throw `'Maximum iteration limit exceeded.'` if the number of iterations exceeds
                    10.
                    <br><br>
                    Usually, you don't call `$digest()` directly in controllers or in directives.
                    Instead, you should call $apply() (typically from within a directive), which will force a
                    `$digest()`.
                    <br><br>
                    If you want to be notified whenever `$digest()` is called, you can register a `watchExpression`
                    function with $watch()} with no `listener`.
                    <br><br>
                    In unit tests, you may need to call `$digest()` to simulate the scope life cycle.
                </aside>
            </section>
            <section>
                <h2>Example of Digesting</h2>
                       <pre>
                           <code data-trim contenteditable>
//let's assume that scope was dependency injected as the $rootScope
var scope = $rootScope;
scope.name = 'misko';
scope.counter = 0;
expect(scope.counter).toEqual(0);
scope.$watch('name', function(newValue, oldValue) {
    scope.counter = scope.counter + 1;
});
expect(scope.counter).toEqual(0);

scope.$digest();
//the listener is always called during the first $digest loop
//after it was registered
expect(scope.counter).toEqual(1);

scope.$digest();
//but now it will not be called unless the value changes
expect(scope.counter).toEqual(1);

scope.name = 'adam';
scope.$digest();
expect(scope.counter).toEqual(2);
                           </code>
                       </pre>
            </section>
            <section>
                <h2>
                    Pitfalls
                </h2>

                <p class="fragment">
                    Doing recursion that triggers a recursive process...
                </p>

                <p class="fragment">
                    Too many watches and things get crazy
                </p>

                <p class="fragment">
                    Testing is often happening outside a cycle
                </p>

            </section>

        </section>

        <!--Stephen-->
        <section>
            <section>
                <h2>Compile, transclusion, pre-link, post link</h2>

                <p class="fragment">
                    How do these actually work???
                </p>

                <p class="fragment">
                    Black magic voodoo and magnets???
                </p>

                <p class="fragment">
                    Believing that Google has your best interests at heart???
                </p>
            </section>
            <section>
                <h2>Compile</h2>

                <p class="fragment">
                    makeTemplate(String || DOM)
                </p>

                <p class="fragment">
                    Transformation happen here
                </p>

                <p class="fragment">
                    This is not often used
                </p>
            </section>
            <section>
                <h2>Example of Compile</h2>
                <pre>
                    <code class="javascript" data-trim contenteditable>
//`tElement` The element where the directive has been declared.
//`tAttrs` Normalized list of attributes declared on this element
// shared between all directive compile functions.
//`transclude` [*DEPRECATED*!]
// A transclude linking function: `function(scope, cloneLinkingFn)`
compile: function compile(tElement, tAttrs, transcludeFn) {
  return {
    pre: function preLink(scope, iElement, iAttrs, controller) {
                        ... },
    post: function postLink(scope, iElement, iAttrs, controller) {
                        ... }
  }
  // or
  // return function postLink( ... ) { ... }
}
                    </code>
                </pre>


                <aside class="notes">
                    `compile`
                    <br><br>
                    function compile(tElement, tAttrs, transclude) { ... }
                    <br><br>
                    The compile function deals with transforming the template DOM.
                    Since most directives do not do template transformation, it is not used often.
                    The compile function takes the following arguments:
                    <ul>
                        <li>
                            `tElement` - template element - The element where the directive has been declared.
                            It is safe to do template transformation on the element and child elements only.
                        </li>
                        <li>
                            `tAttrs` - template attributes - Normalized list of attributes declared on this element
                            shared
                            between all directive compile functions.
                        </li>
                        <li>
                            `transcludeFn` - [*DEPRECATED*!] A transclude linking function: `function(scope,
                            cloneLinkingFn)`
                        </li>
                    </ul>
                    **Note:** The template instance and the link instance may be different objects if the template has
                    been cloned. For this reason it is **not** safe to do anything other than DOM transformations that
                    apply to all cloned DOM nodes within the compile function. Specifically, DOM listener registration
                    should be done in a linking function rather than in a compile function.
                    <br><br>
                    **Note:** The compile function cannot handle directives that recursively use themselves in their
                    own templates or compile functions. Compiling these directives results in an infinite loop and a
                    stack overflow errors.
                    <br><br>
                    This can be avoided by manually using $compile in the postLink function to imperatively compile
                    a directive's template instead of relying on automatic template compilation via `template` or
                    `templateUrl` declaration or manual compilation inside the compile function.
                    <br><br>
                    **Note:** The `transclude` function that is passed to the compile function is deprecated, as it
                    e.g. does not know about the right outer scope. Please use the transclude function that is passed
                    to the link function instead.
                    <br><br>
                    A compile function can have a return value which can be either a function or an object.
                    <ul>
                        <li>
                            returning a (post-link) function - is equivalent to registering the linking function via the
                            `link` property of the config object when the compile function is empty.
                        </li>
                        <li>
                            returning an object with function(s) registered via `pre` and `post` properties - allows you
                            to
                            control when a linking function should be called during the linking phase. See info about
                            pre-linking and post-linking functions below.
                        </li>
                    </ul>
                </aside>
            </section>
            <section>
                <h2>
                    Transclusion
                </h2>

                <p class="fragment">
                    What is it?
                </p>

                <p class="fragment">
                    Is it a made up word?
                </p>

                <p class="fragment">
                    Isn't this what Thoreau and Emerson where into?
                    <image data-src="images/thoreau.jpg"></image>
                </p>
            </section>
            <section>
                <h2>
                    Overview
                </h2>

                <p class="fragment">
                    Copying a collection of DOM elements
                </p>

                <p class="fragment">
                    Putting them into a different part of the DOM<br>
                    (potentially multiple times)
                </p>

                <p class="fragment">
                    The copies maintain their link to the parent scope
                </p>

                <p class="fragment">
                    Digest cycles maybe triggered for this...
                </p>

            <pre class="fragment">
                <code>
                    //Directive definition
                    ...
                    tranclude: true,
                    ...
                    //OR
                    ...
                    transclude: 'element',
                    ...
                </code>
            </pre>

                <aside class="notes">
                    Transclusion
                    <br><br>
                    Transclusion is the process of extracting a collection of DOM element from one part of the DOM and
                    copying them to another part of the DOM, while maintaining their connection to the original
                    AngularJS
                    scope from where they were taken.
                    <br><br>
                    Transclusion is used (often with ngTransclude) to insert the
                    original contents of a directive's element into a specified place in the template of the directive.
                    The benefit of transclusion, over simply moving the DOM elements manually, is that the transcluded
                    content has access to the properties on the scope from which it was taken, even if the directive
                    has isolated scope.
                    <br><br>
                    This makes it possible for the widget to have private state for its template, while the transcluded
                    content has access to its originating scope.
                    <br><br>
                    **Note:** When testing an element transclude directive you must not place the directive at the root
                    of the DOM fragment that is being compiled.
                </aside>
            </section>
            <section>
                <h2>
                    Practical Idea
                </h2>

                <p class="fragment">
                    Allowing a user to pass in a template to be used in your directive...
                </p>

                <p class="fragment">
                    Open/Closed Principle
                </p>
                <pre class="fragment">
                    <code data-trim contenteditable>
<directive>
    <div>
        I will be used as the tranclusion template. <br>
        I will have access to the parent scope.
    </div>
</directive>
                    </code>
                </pre>
            </section>
            <section>
                <h2>Template Example of Transclusion</h2>
            <pre>
                <code data-trim contenteditable>
<div>
    <h2>This is the template of the directive</h2>
    <ng-transclude></ng-transclude>
</div>
                </code>
            </pre>
            </section>
            <section>
                <h2>Code Example of Transclusion</h2>
            <pre>
                <code data-trim contenteditable="">
... link: function (scope, element, attrs, ctrl, transclude) {
    transclude(scope, function (clone) {
        clone.after(element);
    });
    transclude(scope, function (clone) {
        clone.after(element);
    });
}
                </code>
            </pre>
            </section>
            <section>
                <h2>
                    Pitfalls
                </h2>
                <p>
                    ngTransclude and the digest cycle...
                </p>
                <p>
                    Remember you are in the deepest bowels of Ng
                </p>
            </section>
            <!--&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;-->
            <section>
                <h2>Link</h2>

                <p class="fragment">
                    Wire up the template to data... Registrar of watches
                </p>

                <p class="fragment">
                    Happens after cloning
                </p>

                <p class="fragment">
                    Keeper of the directive logic
                </p>

                <p class="fragment">
                    Comes in 'pre' and 'post' flavors
                </p>

                <p class="fragment">
                    DOM transforms only in 'post'
                </p>
            </section>
            <section>
                <h2>Example of Link Functions</h2>

                <pre>
                    <code class="javascript" data-trim contenteditable>
//Defined by the compile function
// OR off of the directive definition object like the compile
link: {
 pre: function preLink(scope,
                        iElement,
                        iAttrs,
                        controller,
                        transcludeFn) {
                        ... },
 post: function postLink(...) {
                        ... }
}
//or
//link: function postLink( ... ) { ... }
                    </code>
                </pre>

                <aside class="notes">
                    `link`
                    <br><br>
                    This property is used only if the `compile` property is not defined.
                    <br><br>
                    function link(scope, iElement, iAttrs, controller, transcludeFn) { ... }
                    <br><br>
                    The link function is responsible for registering DOM listeners as well as updating the DOM. It is
                    executed after the template has been cloned. This is where most of the directive logic will be
                    put.

                    <ul>
                        <li>
                            `scope` - Scope - The scope to be used by the
                            directive for registering watches.
                        </li>
                        <li>
                            `iElement` - instance element - The element where the directive is to be used. It is safe to
                            manipulate the children of the element only in `postLink` function since the children have
                            already been linked.
                        </li>
                        <li>
                            `iAttrs` - instance attributes - Normalized list of attributes declared on this element
                            shared between all directive linking functions.
                        </li>
                        <li>
                            `controller` - the directive's required controller instance(s) - Instances are shared
                            among all directives, which allows the directives to use the controllers as a communication
                            channel. The exact value depends on the directive's `require` property:
                            <ul>
                                <li>
                                    `string`: the controller instance
                                </li>
                                <li>
                                    `array`: array of controller instances
                                </li>
                                <li>
                                    no controller(s) required: `undefined`
                                </li>
                            </ul>
                            If a required controller cannot be found, and it is optional, the instance is `null`,
                            otherwise the Missing Required Controller error is thrown.
                        </li>
                        <li>
                            `transcludeFn` - A transclude linking function pre-bound to the correct transclusion scope.
                            This is the same as the `$transclude`
                            parameter of directive controllers, see there for details.
                            `function([scope], cloneLinkingFn, futureParentElement)`.
                        </li>
                    </ul>

                    Pre-linking function
                    <br><br>
                    Executed before the child elements are linked. Not safe to do DOM transformation since the
                    compiler linking function will fail to locate the correct elements for linking.
                    <br><br>
                    Post-linking function
                    <br><br>
                    Executed after the child elements are linked.
                    <br><br>
                    Note that child elements that contain `templateUrl` directives will not have been compiled
                    and linked since they are waiting for their template to load asynchronously and their own
                    compilation and linking has been suspended until that occurs.
                    <br><br>
                    It is safe to do DOM transformation in the post-linking function on elements that are not waiting
                    for their async templates to be resolved.
                </aside>
            </section>
            <section>
                <h2>High Level</h2>
                <image data-src="images/No-transclusion.svg"></image>
                <p class="fragment">
                    But this is Ng, so it isn't quite that simple...
                </p>
            </section>
            <section>
                <h2>High Level (with transclusion)</h2>
                <image data-src="images/Transclusion.svg"></image>
                <aside class="notes">
                    http://www.jvandemo.com/the-nitty-gritty-of-compile-and-link-functions-inside-angularjs-directives/
                </aside>
            </section>

        </section>

        <!--Troy-->
        <section>
            <section>
                <h2>Achieving Peformance</h2>

                <p class="fragment">Performance Indicators</p>

                <p class="fragment">Avoiding the Digest Cycle</p>

                <p class="fragment">Streamlining the DOM</p>

                <p class="fragment">ng-repeat track by</p>
            </section>
            <section>
                <h2>Performance Indicators</h2>
                <p class="fragment">Time to initial render</p>
                <p class="fragment">Time to perform operations</p>
                <p class="fragment">Total memory consumption</p>
                <p class="fragment">Avoid excessive reflows</p>
                <p class="fragment">Avoid excessive gc</p>
                <aside class="notes">
                    How do we discover these indicators.
                    performance.timing returns a object with a number of timing events.
                    Use Chrome timeline to find GC thrashing, memory leeks, reflows (chrome marks them)
                </aside>
            </section>
            <section>
                <h2>GC Thrash Example</h2>
                <img src="images/GCThrash.png"/>                                
            </section>
            <section>
                <h2>Reflow Thrash Example</h2>
                <img src="images/Reflows.png"/>
            </section>
            <section>
                <h2>Memory Leak Example</h2>
                <img src="images/MemoryLeak.png"/>
            </section>
            <section>
                <h2>Avoiding the Digest Cycle</h2>
                <p class="fragment">Digest cycle is expensive</p>
                <p class="fragment">Causes lots of DOM Manipulation</p>
                <p class="fragment">When using recursive includes it runs every time it encounters another include</p>
                <p class="fragment">Limit to ten levels deep</p>
                <aside class="notes">
                    Digest cycle has to run all the watches on the page which could be many for a large tree in
                    addition to all the other things on the page and these watchers could themselves cause DOM changes which
                    trigger additional digest cycles.
                </aside>
            </section>
            <section>
                <h2>Streamlining the DOM</h2>

                <p class="fragment">Convert tree structure to flat list</p>
                <ul>
                    <li class="fragment">Reduces the number of DOM nodes</li>
                    <li class="fragment">Reduces the complexity of the DOM tree</li>
                    <li class="fragment">Uses autogenerated styles to indent the nodes the proper amount</li>
                    <li class="fragment">Use one ng-repeat with track by ID</li>                                   
                </ul>
 
                <aside class="notes">
                   Typically trees are done using nested ul
                   Browser is good at processing styles use dynamically set padding-left
                    More efficient to find the node in the backing tree structure than to render the tree structure and use data binding; the DOM is expensive.
                    Tracking by ID prevents angular from comparing all the objects to prevent duplicates and rerendering the template if the underlying object 
                    is a different object but the data hasn't changed
                </aside>
            </section>
            <section>
                <h2>Typical Representation of a Tree in the DOM</h2>
               <pre>
                   <code class="html" data-trim contenteditable>
&lt;ul&gt;
   &lt;li&gt;
       &lt;node&gt;Node template here&lt;/node&gt;
       &lt;ul&gt;
          &lt;li&gt;
              &lt;node&gt;Node template here&lt;/node&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;Another node....&lt;/&gt;
&lt;/ul&gt;
                   </code>
               </pre>                
            </section>
            <section>
                <h2>Flat Representation</h2>
                
               <pre>
                   <code class="html" data-trim contenteditable>
&lt;ul&gt;
   &lt;li style="padding-left:0px"&gt;
       &lt;node&gt;Node template here&lt;/node&gt;
    &lt;/li&gt;
   &lt;li style="padding-left:20px"&gt;
       &lt;node&gt;Node template here&lt;/node&gt;
    &lt;/li&gt;
   &lt;li style="padding-left:0px"&gt;
       &lt;node&gt;Node template here&lt;/node&gt;
    &lt;/li&gt;
&lt;/ul&gt;
                    </code>
                </pre>                      
            </section>
            <section>
                <h2>The Display List</h2>

                <p class="fragment">Use an actual tree data structure to perform tree operations</p>
                <p class="fragment">Use topological sort to create the display list</p>
                <p class="fragment">Simple approach of regenerating the display list on most changes</p>
                <p class="fragment">Top sort is heavily used and therefore needs to be optimised significantly</p>
                
                <aside class="notes">
                    Trees can be represented as matrices and adjacency lists but doing so for multiple tries of non uniform shape and size is difficult
                    Therefore we maintain an actual tree data structure rather than just using the display list for everything
                    Manipulating the tree in memory and regenerating the display list is much faster than having to write out the extra DOM nodes and deal with the extra digest cycles
                    The display list could be updated in a more targeted fashion to achieve better performance
                    From wikipedia:
                    ...is a linear ordering of its vertices such that for every directed edge uv from vertex u to vertex v, u comes before v in the ordering.
                    Any DAG has at least one topological ordering, and algorithms are known for constructing a topological ordering of any DAG in linear time
                    Our algorithm is a DPS because the top level parents have no incoming edges and each node only has a single parent, this simplifies the typical top sort algorithms
                    Show actual code here
                </aside>
            </section>
        </section>

        <section>
            <section>
                <h2>Communication</h2>

                <p class="fragment">How does the consumer communicate with the tree?</p>
                <p class="fragment">How do you avoid broadcasts everywhere?</p>
                <p class="fragment">How do you maintain an isolate scope for you directive?</p>
            </section>
            <section>
                <h2>Promise Magic</h2>

                <p class="fragment">Provide endpoints for the consumer to pass a callback function that returns a promise.</p>
                <p class="fragment">The consumer performs the operations it needs and resolves the promise with the result structured as specified by the tree.</p>
                <p class="fragment">The tree registers a callback with the promise to perform the operations it needs when it is resolved/rejected.</p>
                <p class="fragment">This allows for very specific and controlled interaction points with the directive.</p>
                <p class="fragment">Disadvantage is that it adds more complexity to the setup of the directive.</p>
                
                <aside class="notes">
                    Allows you to avoid prototypical inheritance and broadcast.
                </aside>
            </section>
            <section>
                <h2>Consumer Side Example</h2>
                <p>Pass this function into the tree's on-edit attribute</p>
                <pre>
                    <code class="javascript" data-trim contenteditable>
function editTag (node) {

    var editResultDeferred = $q.defer();

    if (!node) {
        editResultDeferred.reject('node argument is required');
    }
    else {
        var modalInstance = $modal.open({
            templateUrl: 'views/templates/tag-modification-modal.tpl.html',
            controller: 'TagModificationModalController as modTagVm',
            resolve: {
                tag: function () {
                    var tagToModify = node.data;
                    tagToModify._id = node.id;
                    tagToModify.parentId = node.parentId;
                    return tagToModify;
                },
                configuration: function () {
                    return tagModificationModalConfigurations.editing;
                }
            }
        });
        modalInstance.result.then(function (modifiedTagData) {
            alertService.addAlert('success', messageText.savedChangesAlert);
            editResultDeferred.resolve(modifiedTagData);
        }, function() {
            editResultDeferred.reject();
        });
    }

    return editResultDeferred.promise;
}
                    </code>
                </pre>
            </section>
            <section>
                <h2>Tree Side Example</h2>
                <p>Execute the on-edit function and register a callback to the returned promise</p>
                <pre>
                    <code class="javascript" data-trim contenteditable>
function edit(node) {
    var onEditPromise = treeVm.onEdit({node: node});

    onEditPromise.then(function (editEvent) {
        var nodeToEdit = treeVm.masterTree.find(displayListNode.path);
        nodeToEdit.remove();
        parent.append(treeService.createSubTree(editedNodeAndSiblings[0], defaultNode));        

        treeVm.displayList = treeService.topologicalSort(treeVm.masterTree);

        refreshSelectedState(displayListNode.id);
    });
}
                    </code>
                </pre>
            </section>
        </section>

        <section>
            <h2>Unit Testing Setup/framework gulp</h2>
        </section>
        
        <section>
            <h2>Questions?</h2>
        </section>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>

    // Full list of configuration options available at:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
            {
                src: 'lib/js/classList.js', condition: function () {
                return !document.body.classList;
            }
            },
            {
                src: 'plugin/markdown/marked.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'plugin/markdown/markdown.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'plugin/highlight/highlight.js', async: true, condition: function () {
                return !!document.querySelector('pre code');
            }, callback: function () {
                hljs.initHighlightingOnLoad();
            }
            },
            {src: 'plugin/zoom-js/zoom.js', async: true},
            {src: 'plugin/notes/notes.js', async: true}
        ]
    });

</script>

</body>
</html>
